use chrono::Local;
use std::fs::{File, OpenOptions};
use std::io::Write;
use std::path::PathBuf;

pub(crate) struct MarkdownGenerator {
    file: File,
}

impl MarkdownGenerator {
    pub(crate) fn new(path: &PathBuf) -> Self {
        Self {
            file: OpenOptions::new()
                .create(true)
                .write(true)
                .truncate(true)
                .open(path)
                .expect(&format!("Unable to open file {:#?}", path)),
        }
    }

    fn write(&mut self, content: &str) {
        let error = &format!("Unable to write to file {:#?}", self.file);
        writeln!(self.file, "{}", content).expect(error);
    }

    fn newline(&mut self) {
        self.write("");
    }

    fn format_files(&self, files: &Vec<&str>) -> String {
        let formatted_files: Vec<String> =
            files.iter().map(|f| format!("[{}]({})", f, f)).collect();
        formatted_files.join(", ")
    }

    pub(crate) fn generate_markdown(
        &mut self,
        commits: &Vec<Vec<String>>,
        couplings: &Vec<&(Vec<&str>, usize)>,
        minimum_frequency: &u32,
        minimum_size: &u32,
        ignore: &Vec<String>,
    ) {
        let formatted_date = Local::now().format("%Y-%m-%d %H:%M:%S").to_string();
        self.write("# Coupling analysis report");
        self.newline();
        self.write(&format!("**Date generated**: {}", formatted_date));
        self.newline();
        self.write(&format!(
            "**Generated by**: {} v{}",
            env!("CARGO_PKG_NAME"),
            env!("CARGO_PKG_VERSION")
        ));
        self.newline();
        self.write("## Overview");
        self.newline();
        self.write("This report summarizes the analysis of commit history to identify files that are frequently edited together. High coupling between files may indicate design or dependency issues that could benefit from refactoring.");
        self.newline();
        self.write("## Configuration");
        self.newline();
        self.write(&format!("**Minimum size**: {}", minimum_size));
        self.newline();
        self.write(&format!("**Minimum frequency**: {}", minimum_frequency));
        self.newline();
        self.write(&format!("**Ignore patterns**: {:#?}", ignore));
        self.newline();
        self.write("## Key Metrics");
        self.newline();
        self.write(&format!("**Commits analyzed**: {}", commits.len()));
        self.newline();
        self.write(&format!(
            "**Total couplings analyzed**: {}",
            couplings.len()
        ));
        self.newline();
        self.write(&format!(
            "**Most frequent coupling**: {} (**{}** instances found)",
            self.format_files(&couplings[0].0),
            couplings[0].1
        ));
        self.newline();
        self.write("## Full coupling data");
        self.newline();
        couplings.iter().for_each(|coupling| {
            self.write(&format!("**Coupling**: {}", self.format_files(&coupling.0)));
            self.newline();
            self.write(&format!("**Instances found**: {}", coupling.1));
            self.newline();
        });
    }
}
